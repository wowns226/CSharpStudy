# 클래스

## 객체지향 프로그래밍
* 객체지향 프로그래밍(OOP)는 코드 내의 모든 것을 객체로 표현하고자 하는 프로그래밍 패러다임을 뜻한다.
* 세상의 모든 것을 객체로 표현할 수 있으며, 객체는 속성과 기능으로 구성된다.
* 사람으로 예를 든다면,
    - 속성으로는 피부색, 키, 몸무게 등이 있을 것이고
    - 기능으로는 걷기, 뛰기, 보기, 듣기 등이 있을 것이다.
* C#에서는 `속성`은 `데이터`로, `기능`은 메소드로 표현된다.
* 즉, C#에서 객체는 데이터와 메소드로 이루어져 있다.

## 클래스와 객체
* 클래스는 `객체를 만들기 위한 청사진`이다.
* 예를 든다면,
    - 클래스를 자동차 설계도라고 한다면, 객체는 생산된 실체 자동차이다.
* 클래스는 속성과 기능을 정의하는 역할을 한다.
* 그 클래스를 가지고 객체를 생성해야 속성과 기능을 가진 실체가 만들어지며 메모리 공간을 차지한다.
* 객체를 `인스턴스(Instance)`라고 부르기도 한다.

## 클래스의 선언과 객체 생성
```c#
class 클래스이름
{
    // 데이터와 메소드
}
```
```c#
class Person
{
    // 멤버
    public int age;     // 필드
    public int height;  // 필드
    public int weight;  // 필드

    public void Run(){} // 메소드
    public void Eat(){} // 메소드
}

static void Main()
{
    Person temp1_person = new Person(); // temp1_person 객체 생성
    Person temp2_person = new Person(); // temp2_person 객체 생성
}
```
* 클래스 안에 선언된 변수들을 일컬어 `필드(Field)`라고 한다.
* 필드와 메소드를 비롯하여 프로퍼티, 이벤트 등 클래스 내에 선언된 요소들을 일컬어 `멤버(Member)`라고 한다.\
* `new Person()`에서 `Person()`은 객체를 생성하는 역할인 `생성자`이고, `new` 키워드는 객체를 생성하는데 사용하는 연산자이다.
* 모든 클래스는 `복합 데이터 형식(참조 형식)`이다.
* [[Code]](/Code/Chapter07/BasicClass.cs)

## 생성자와 종료자
* 객체가 생성될 때 `생성자`가 호출되고 소멸할 때 `종료자`가 호출된다.
* [[Code]](/Code/Chapter07/Constructor.cs)

### 생성자
```c#
class 클래스이름
{
    한정자 클래스이름( 매개변수_목록 )
    {

    }

    // 필드
    // 메소드
}
```
* 명시적으로 생성자를 구현하지 않아도 컴파일러에서 자동으로 `생성자(기본 생성자)`를 만들어준다.
* 매개변수를 입력받아 원하는 값으로 필드를 초기화할 수 있는 최적의 장소이다.
* 생성자도 오버로딩이 가능하여 다양한 생성자를 구현할 수 있다.

### 종료자
* 클래스 이름 앞에 `~`을 붙인다.
* 생성자와 달리 매개변수와 한정자가 없다.
* 오버로딩이 불가능하며 직접 호출도 할 수 없다.
* CLR의 가비지 컬렉터가 객체 소멸 시점을 판단해서 종료자를 호출해준다.
```c#
class 클래스이름
{
    ~클래스이름()
    {

    }
}
```
* CLR의 가비지 컬렉터가 언제 동작할지 예측할 수 없기 때문에 가급적 사용하지 않는 것이 좋다.
* 종료자를 명시적으로 구현하면 클래스의 족보를 타고 올라가 상속받은 `Finalize()` 메소드를 호출하는데 이 과정에서 응용 프로그램의 성능 저하를 초래할 확률이 높다.

## 얕은 복사와 깊은 복사
* [얕은 복사와 깊은 복사](/Explaination/ShallowCopy_DeepCopy.md)

## this 키워드
* 객체가 `자신을 지칭`할 때 사용하는 키워드이다.
* [[Code]](/Code/Chapter07/This.cs)

## this() 생성자
* [[Code]](/Code/Chapter07/ThisConstructor.cs)