# 상속

## 접근 한정자
* [접근 한정자](/Explaination/AccessModifier.md)

## 상속
* 객체지향 프로그래밍에서 물려받는 `클래스(파생 클래스, 자식 클래스)`가 데이터를 물려줄 `클래스(기반 클래스, 부모 클래스)`를 지정한다.
```c#
class 기반_클래스
{
    // 멤버 선언
}

class 파생_클래스 : 기반_클래스
{
    // 기반 클래스의 private로 선언되지 않은 모든 것을 가진다.
}
```
* 생성 과정
    1. 기반 클래스의 생성자
    2. 파생 클래스의 생성자
    3. 파생 클래스의 종료자
    4. 기반 클래스의 종료자
* base 키워드
    - `base 키워드`는 `기반 클래스`를 가리킨다.
* [[Code]](/Code/Chapter07/Inheritance.cs)

## 기반 클래스와 파생 클래스 사이의 형식 변환, is와 as 연산자
* 형식 변환을 위해 `is`와 `as`를 제공한다.

| 연산자 |                                                                설명                                                                |
| :----: | :--------------------------------------------------------------------------------------------------------------------------------: |
|   is   |                                  객체가 해당 형식에 해당하는지 검사하여 그 결과를 bool값으로 반환                                  |
|   as   | 형식 변환 연산자와 같은 역할<br>형식 반환 연산자가 변환에 실패하는 경우 예외를 던지는 반면에 as 연산자는 객체 참조를 null로 만든다 |

* `as` 연산자는 참조 형식에 대해서만 사용이 가능하다.
* [[Code]](/Code/Chapter07/TypeCasting.cs)

## 오버라이딩과 다형성
* 부모 클래스에서 선언된 함수를 `virtual` 키워드를 추가 하여 선언하고 자식클래스에서 `override` 키워드를 통하여 오버라이딩을 할 수 있다.
* `private`로 선언된 메소드는 오버라이딩할 수 없다.
* 부모 클래스에서의 기능도 같이 실행하고 싶으면 `base` 키워드를 이용하면 된다.
* [[Code]](/Code/Chapter07/Overriding.cs)

## 메소드 숨기기
* CLR에게 기반 클래스에서 구현된 메소드를 감추고 파생 클래스에서 구현된 것만 보여주는 것을 말한다.
* 파생 클래스 메소드에 `new` 한정자를 수식한다.
    - 생성자를 호출할 때 사용하는 `new` 연산자와는 아예 다른 것이다.
* [[Code]](/Code/Chapter07/MethodHiding.cs)

## 오버라이딩 봉인하기
* 클래스를 봉인하는 것처럼 메소드도 `sealed` 키워드를 이용해서 봉인할 수 있다.
* [[Code]](/Code/Chapter07/SealedMethod.cs)
    - 위 코드를 실행하면 컴파일 에러가 난다.
* 왜 `virtual`로 선언된 메소드만 봉인 메소드로 만들 수 있을까?
    - `virtual`로 선언되었다는건 오버라이딩을 할 수 있다는 의미이다.
    - 오버라이딩한 메소드는 파생 클래스의 파생 클래스에서도 자동으로 오버라이딩이 가능하다.
    - 이 곳에 오버라이딩을 막을 수 있는 브레이크 역할인 `sealed` 한정자가 필요한 것이다.

## 읽기 전용 필드
* 상수는 `const` 키워드를 이용해서 선언한다.
* 읽기 전용 필드는 `readonly` 키워드를 이용해 선언한다.
* 생성자 안에서만 읽기 전용 필드의 초기화가 가능하다.
* [[Code]](/Code/Chapter07/ReadonlyFields.cs)

## 중첩 클래스
* 클래스 `내부에 선언`되어 있는 클래스를 의미한다.
* 왜 중첩 클래스를 사용하는 것일까?
    - 클래스 외부에 공개하고 싶지 않은 형식을 만들고자 할 때
    - 현재 클래스의 일부분처럼 표현할 수 있는 클래스를 만들고자 할 때
* [[Code]](/Code/Chapter07/NestedClass.cs)

## 분할 클래스
* 여러 번 `나눠서 구현`하는 클래스를 의미한다.
* 클래스의 구현이 길어질 경우 여러 파일에 나눠서 구현할 수 있게함으로ㅓ써 소스 코드 관리의 편의를 제공하는 데 의미가 있다.
* `partial` 키워드를 이용하여 사용한다.
* [[Code]](/Code/Chapter07/ParitalClass.cs)

## 확장 메소드
* `기존 클래스의 기능을 확장`하는 기법이다.
* 기반 클래스를 물려받아 파생 클래스를 만든 뒤 필드나 메소드를 추가하는 상속과는 다르다.
* `static` 한정자로 수식한다.
* 메소드의 첫 번째 매개변수는 반드시 `this` 키워드와 함께 확장하고자 하는 클래스의 인스턴스여야 한다.

```c#
namespace 네임스페이스이름
{
    public static class 클래스이름
    {
        public static 반환_형식 메소드이름( this 대상형식 식별자, 매개변수_목록 )
        {
            //
        }
    }
}
```
* [[Code]](/Code/Chapter07/ExtensionMethod.cs)