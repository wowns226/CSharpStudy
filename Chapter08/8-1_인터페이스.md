# 인터페이스와 추상 클래스

## 인터페이스
```c#
interface 인터페이스이름
{
    반환_형식 메소드_이름1( 매개변수_목록 );
    반환_형식 메소드_이름2( 매개변수_목록 );
    반환_형식 메소드_이름3( 매개변수_목록 );
}
```
* 인터페이스는 메소드, 이벤트, 인덱서, 프로퍼티만 가질 수 있다.
* 인터페이스는 구현부가 없다.
* 클래스는 접근 제한 한정자를 수식하지 않으면 기본적으로 `private`로 선언되지만, 인터페이스는 접근 제한 한정자를 사용할 수 없고 모든 것이 `public`으로 선언된다.
* 인터페이스를 상속받는 파생 클래스는 인터페이스에 선언된 모든 메소드 및 프로퍼티를 구현해줘야 한다.
* [[Code]](/Code/Chapter08/Interface.cs)

## 인터페이스의 작명법
* C#에서는 인터페이스의 이름 앞에 `I`를 붙여준다.

## 인터페이스를 상속하는 인터페이스
* 인터페이스를 상속할 수 있는 것은 클래스뿐만이 아닌 `구조체`, `인터페이스`도 가능하다.
```c#
interface 파생_인터페이스 : 부모_인터페이스
{
    // 메소드 목록...
}
```
* [[Code]](/Code/Chapter08/DerivedInterface.cs)

## 인터페이스 다중 상속
* 클래스는 다중 상속을 지원하지 않는다.
    - `죽음의 다이아몬드`라는 문제때문이다.[[추가설명]](/Explaination/Diamond_of_Death.md)
* 인터페이스의 다중 상속을 통하여 클래스의 다중 상속의 역할을 흉내낼 수 있다.
* [[Code]](/Code/Chapter08/MultiInterfaceInheritance.cs)

## 인터페이스의 기본 구현 메소드
* [[Code]](/Code/Chapter08/DefaultImplementation.cs)

## 추상클래스
* 추상 클래스는 `구현`을 가질 수 있지만 `인스턴스`는 만들 수 없다.
* 클래스 선언부에서 `abstract` 키워드를 이용해서 선언한다.
* 접근 한정자를 명시하지 않으면 자동으로 `private`로 선언된다.
```c#
abstract class 클래스이름
{
    // 클래스와 동일하게 구현
}
```
* 추상 메소드
    - 추상 클래스가 인터페이스의 역할도 할 수 있게 해주는 장치이다.
    - 구현을 갖지는 못하지만 파생 클래스에서 반드시 구현하도록 강제한다.
* [[Code]](/Code/Chapter08/AbstractClass.cs)

* 추상 클래스와 추상 메소드는 `이 클래스를 파생 클래스로 만들어 사용하고 추상 메소드를 오버라이딩해서 사용해라`라는 의미이다.

## 인터페이스와 추상클래스의 차이
|    구분    |                      인터페이스                       |                  추상클래스                  |
| :--------: | :---------------------------------------------------: | :------------------------------------------: |
| 접근한정자 | 함수에 대한 접근 한정자 명시X<br> 기본적으로 `public` | 접근 한정자 명시 O <br> 기본적으로 `private` |
|    구현    |                           X                           | O<br>추상 메소드의 경우 파생 클래스에서 구현 |
|    필드    |                           X                           |     O<br> 클래스와 비슷하기 때문에 가능      |
|  다중상속  |                           O                           |                      X                       |